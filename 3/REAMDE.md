# Лабораторная работа № 3 «иерархия классов»

## Общие требования

1. Проект на git'е.

2. Наличие интерактивного диалогового интерфейса для проверки корректности разработанной программы.

3. Корректное завершение программы, как в случае штатного выхода, так и в случае невосстановимых ошибок (без утечек и без использования функций мгновенного завершения программы exit, abort, std::terminate и пр.).

4. Проверка корректности ввода (работа только через потоки C++, т. е. без scanf/printf/fscanf/fprintf). В случаях ошибок формата ввода запрос повторного ввода данных. В случае невосстановимых ошибок ввода-вывода завершение программы.

5. Использование средств языка C++ для работы с динамической памятью - операторов new и delete (malloc, calloc, realloc, free запрещены).

6. Использование исключений для обработки ошибочных ситуаций (вместо кодов возврата).

7. Предпочтительно использование стандартных библиотек и функций языка C++ вместо библиотек и функций языка C (std::copy вместо memcpy, std::abs вместо abs, cstring вместо string.h и т.д.).

8. Логичная и удобная структура проекта, где каждая единица (файл/библиотека) обладает своей единой зоной ответственности (каждый класс в своих файлах .h и .cpp, диалоговые функции и main в своих).

9. Наличие средств автосборки проекта (желательно CMake, qmake и прочие, работающие "поверх" Makefile; использование самописного Makefile нежелательно, но допустимо).

10. Статический анализ кода, встроенный инструментарий в IDE (пр. VS2019: Analyze->Run Code Analysis, см. также Project -> Properties -> Configuration Properties -> Code Analysis -> Microsoft -> Active Rules) или внешние инструменты (Sonarqube + extensions, Clang Static Analyzer и д.р.) (обязательно знакомство с инструментом, исправление всех замечаний или обоснование в комментарии почему конкретное замечание исправить нельзя).

11. Динамический анализ на утечки памяти, встроенный инструментарий в IDE / библиотеки (Пр., VS2019) или внешние инструменты (valgrind, Deleaker и т.п.). Отсутствие утечек памяти и прочих замечаний анализатора.

12. Не "кривой", не избыточный, поддерживаемый и расширяемый код (разумная декомпозиция, DRY, корректное использование заголовочных файлов и т.п.).

13. Стандарт языка C++20 (рекомендуется). Допустим C++17 (если почему-то нет С++20).

## Требования задачи

1. На выбор предоставляется две категории вариантов: простые и сложные. Сложные варианты обладают дополнительным множителем для баллов, получаемых за пункты задания "UML", "Реализация", "Прикладная программа", "Тестирование" и "Многопоточность". Множитель, указанный в варианте, является ориентировочным и может меняться по усмотрению преподавателя. При выборе варианта также обратите внимание на то, что для простых вариантов отсутствуют дополнительные задания "динамическая загрузка" и "плагины".

2. Разработка модульных тестов для классов, удовлетворительное (не менее 50%) покрытие методов классов модульными тестами.

3. Использование фреймворков для тестирования решения (gtest, catch2 и пр.). Тестирование встроенными средствами языка запрещено.

4. Логичная структура решения, разделение на зоны ответственность (отдельные компоненты вынести в отдельные библиотеки), следование принципам SOLID.

5. Документирование всех публичных методов шаблонного и расширяемого классов (для простых вариантов — всех классов) с использованием doxygen. Документация метода должна включать в себя как минимум описание всех аргументов метода, описание возвращаемого значения и описание всех исключений, которые могут быть выброшены в этом методе (для каждого указать тип исключения и в каких случаях оно может возникнуть).

6. Корректность состояния классов, отсутствие избыточности, наличие необходимых конструкторов и деструктора, корректность сигнатуры методов, сохранение семантики перегружаемых операторов и корректность их сигнатуры, сохранение семантики работы с потоками ввода/вывода для перегружаемых операторов сдвига.

7. Строгое следование схемам MVC или MVP при проектировании программы. То есть классы программы необходимо разделить на 3 категории (библиотеки):

    - Классы внутренней логики программы (model)
    - классы отображения (view)
    - классы управления/представления (controller/presenter)

    Допускаются объединение view и controller/presenter в один компонент.

8. Динамический анализ (thread sanitizer и т.п.) многопоточной программы на отсутствие состязаний (race condidion). Наличие состязаний в финальной версии программы не допускается.

9. Основной язык программирования — C++. **По согласованию с преподавателем**, принимающим лабораторные работы, допускается использование Java или C#.

## Порядок выполнения работы

### UML

Выполнить проектирование диаграммы классов реализуемой программы в нотации UML (рекомендуется использовать специализированный редактор, например, modelio) и разработку соответствующих диаграмме прототипов классов (хедеров). Допустима генерация UML-диаграммы из кода или кода из UML-диаграммы, однако в любом случае диаграмма классов и их прототипы должны полностью соответствовать друг другу

### Реализация

Выполнить реализацию всех классов, отвечающих за логику программы. Для проверки реализованных классов использовать тесты или простую проверочную main функцию

### Прикладная программа

Реализовать прикладную программу для работы с разработанными классами. Возможно выполнение пункта в 1 из 3 вариантов

- диалоговая программа (до 2 баллов)

- псевдографическая программа (обязательно интерактивное навигирование при помощи клавиш без нажатия Enter, например, с использованием библиотеки ncurses) (до 5 баллов)

- графическая программа (до 8 баллов)

### Шаблон

Выполнить реализацию указанного в задании контейнера в виде шаблонного класса. Разработанный шаблонный класс должен обладать основными методами (вставка, поиск, удаление и т.д.) и предоставлять полноценный интерфейс доступа при помощи итераторов.
Класс итератора должен соответствовать выбранной категории (random access, bidirectional, forward или прочие). Выбор категории итератора необходимо обосновать. В учебных целях, при реализации своего шаблонного контейнера, запрещается использовать контейнеры STL. Использовать умные указатели можно.

### Тестирование

Разработать тесты для классов логики. Написание unit тестов для интерфейса пользователя (контроллера/представления и отображения) не требуется

### Документация

Составить документацию для расширяемого и шаблонного классов (см. требования). Для простых вариантов вместо этого составить документацию для всех разработанных классов логики. Документировать классы пользовательского интерфейса не требуется

### Многопоточность

Модифицировать программу таким образом, чтобы указанный в задании алгоритм выполнятся параллельно в несколько потоков. Необходимо использовать предоставляемые языком примитивы синхронизации для избежания состязаний. Сравнить скорость выполнения одной и той же операции в однопоточном и многопоточном режимах в зависимости от объёма данных (построить график)

### Динамическая загрузка\*

Обеспечить динамическую загрузку для наследников расширяемого (см. в задании) класса из динамических библиотек (.so/.dll). При запуске программа должна загружать все библиотеки, представленные в некотором каталоге, считывать их метаинформацию и использовать при дальнейшей работы. Перенести всех реализованных наследников расширяемого класса в динамические библиотеки в качестве примера.

### Плагин\*

Обменяться своим кодом с другими студентами и выполнить реализацию своего плагина для кода другого студента. Плагин представляет из себя новог наследника расширяемого класса, собранного в виде динамической библиотеки. Модифицировать код другого студента не допускается

### Примечание

Пункты задания от "UML" до "Прикладная программа" необходимо выполнять и сдавать строго в указанной последовательности. Приступать к выполнению следующего пункта до сдачи предыдущего крайне не рекомендуется, так как при обнаружении ошибок на более ранних этапах придётся переделывать всю программу целиком от первых и до последних этапов

## Индивидуальное задание (Вариант T)

Подземелье. Бродяга (1.5)

В данной игре жанра RPG персонаж, управляемый игроком, перемещается по подземелью и уничтожает встретившихся врагов, а также использует разбросанные по подземелью, лежащие в сундуках и остающиеся после смерти врагов предметы. За каждого убитого врага персонаж получает опыт, а при достижении определенного количества опыта уровень персонажа повышается. Цель персонажа - спуститься до самого последнего уровня подземелья.

Персонаж обладает некоторыми первичными характеристиками, такими как сила, ловкость, выносливость, максимальное/текущее здоровье и т.д.. Из них вычисляются реальные значения, такие как вероятность попадания, бонус к урону, бонус к защите, вероятность взлома и пр. После каждого повышения уровня персонаж может повысить свои первичные характеристики.

Враги, населяющие подземелье, имеют различные характеристики атаки, защиты, здоровья и т.д., а также каждый из них обладает определённой характерной чертой (например человекоподобный, насекомое, животное, нежить, демонический, ледяной, ...).

<ins>Предметы</ins><sup>3</sup> в подземелье бывают следующих видов: <ins>зелья</ins>, <ins>оружие</ins>, <ins>снаряжение</ins> и <ins>связки отмычек</ins>. Персонаж может носить с собой некоторое кол-во зелий и выпивать их при необходимости, что повышает какую-то характеристику персонажа. Отмычки можно подобрать для дальнейшего взлома сундуков. Снаряжение (шлем, амулет, броня и т.д.) нельзя носить с собой, но можно надеть, причём не более одной единицы каждого вида снаряжения одновременно. Оружие также нельзя носить с собой, но можно экипировать.

Каждое оружие имеет диапазон (или формулу), из которого генерируется урон наносимый персонажем при каждом ударе, а также добавляется бонусный урон рассчитанный из первичных характеристик. Аналогично каждое снаряжение имеет диапазоны (или формулы), из которых генерируются параметры защиты, которые суммируются и добавляются к бонусной защите.

Кроме этого, снаряжение и оружие может быть <ins>артефактом</ins>, что означает что экипированный предмет не только характеризует показатели защиты/атаки, но и повышает некоторые первичные характеристики. Оружие также бывает <ins>зачарованным</ins>. Это означает что данное оружие обладает характерной чертой, благодаря которой может наносить увеличенный/уменьшенный в кратное число раз урон врагам с определённой чертой (например, освещённое наносит повышенный урон нежити и демоническим врагам, но пониженный человекоподобным). Артефактное оружие такжке может быть зачарованным.

Персонаж также может попытаться открыть сундук (хранящий какой-то предмет) отмычкой, в результате чего либо открывается замок и хранимый предмет появляется на месте сундука, либо просто не удаётся открыть, либо ломается отмычка. Вероятность каждого исхода зависит от уровня замка и первичных характеристик персонажа.

Разработать приложение, позволяющее описывать подземелье и процесс игры. Обеспечить загрузку информации о типах предметов и врагов из конфигурационных файлов, загрузку карты из файлов карты, а также возможность загрузки и сохранения текущего состояния приложения на диск. Для хранения в памяти информации о предметах, персонаже, врагах и нежити используются соответствующие описатели.

Информация обо всех характеристиках персонажа сведена в <ins>таблицу</ins> характеристик. Каждый элемент таблицы содержит краткое и полное название и текущее значение. Хранятся только первичные характеристики.

Описатель <ins>оружия</ins> содержит название и параметры урона.

Описатель <ins>снаряжения</ins> содержит название, тип(место надевания) и параметры защиты.

Описатель <ins>зелья</ins> содержит название и список изменяемых характеристик с величиной изменения после употребления.

Описатель <ins>связки отмычек</ins> содержит название и кол-во отмычек в связке.

Описатель <ins>артефакта</ins> содержит название, список характеристик и модификаторы, получаемых при экипировки артефакта.

Описатель <ins>зачарованного оружия</ins> содержит название, список характерных черт с множителями.

Описатель <ins>персонажа</ins> содержит следующую информацию: накопленный опыт, <ins>таблица характеристик</ins> персонажа, описатель <ins>оружия</ins>, список описателей надетого <ins>снаряжения</ins> (снаряжение каждого типа может встречаться только один раз), список носимых <ins>зелий</ins>, максимальное кол-во носимых зелий, количество отмычек.

Описатель <ins>сундука</ins> содержит уровень замка и описатель предмета, хранящегося в сундуке.

Описатель <ins>врага</ins> содержит следующую информацию: название, максимальное и текущее здоровье, характеристики урона, попадания, опыт, описатель носимого предмета. Если здоровье врага падает до 0, вместо врага появляется носимый предмет, а его опыт переходит персонажу.

Описатель <ins>подземелья</ins> содержит описатели персонажа, врагов, номер текущего уровня и <ins>уровни-матрицу</ins><sup>1</sup> прямоугольных полей, разделённых на <ins>клетки</ins>: пол, открытая дверь, закрытая дверь, лестница вверх и вниз. Лестница вниз на верхнем уровне должна совпадать с лестницей вниз нижестоящего. Каждая клетка может указывать на <ins>описатель предмета</ins> лежащего на ней и описатель сундука стоящего на ней.

Обеспечить выполнение как минимум следующих операций, при помощи которых можно реализовать процесс игры:

- Для подземелья (уровня):
  - получение/изменение размеров игрового поля
  - получение/изменение типа клетки с заданной координатой в процессе загрузки уровня
  - открыть/закрыть указанную дверь
- Для таблицы:
  - получение/изменение характеристики по краткому названию
  - получить количество хранящихся характеристик
- Для оружия:
  - получение/изменение характеристик оружия
  - сгенерировать наносимый урон
- Для сундука:
  - получение/изменение параметров сундука
  - назначить предмет, как хранимый сундуком
  - попытаться открыть сундук
- Для врага:
  - получение/изменение параметров врага
  - получить наносимый урон
  - нанести урон врагу
- Для персонажа:
  - получение/изменение параметров персонажа
  - взять предмет и на основанни его типа поместить на место оружия, в список зелий, на место снаряжения или увеличить число носимых отмычек
  - выпить зелье и поднять соответствующие характеристики в списке
  - стенерировать наносимый урон (с учетом бонусов и экипировки)
  - получить наносимый урон (с учётом защиты)
  - улучшить какую-либо из характеристик (сила, ловкость, выносливость, ...) за счёт уменьшення набранного опыта
- Для приложення в целом:
  - совершить одну итерацю игры (ход/тик)<sup>2</sup>

<sup>1</sup> Шаблонный класс - матрица (обращение к элементам - `matr[i][j]`).  
<sup>2</sup> Указанную операцию реализовать в многопоточном режиме. Каждая группа врагов обрабатывается в отдельном потоке.  
<sup>3</sup> Расширяемый класс - предмет. Необходимо предусмотреть возможность переопределення основных операций предмета в новом классе-наследнике (например, свиток заклинания, позволяющий персонажу сотворить некоторое заклинанне ограниченное количество раз).
